name: Generate Release Assets

on:
  release:
    types: [published]

permissions:
  actions: write
  contents: write

jobs:
  check-version:
    name: Check and Update Version
    runs-on: ubuntu-latest
    outputs:
      version-matched: ${{ steps.check.outputs.version-matched }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.repository.default_branch }}
      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email \
            "github-actions[bot]@users.noreply.github.com"
      - name: Check Version and Update if Needed
        id: check
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Extract version from tag (remove 'v' prefix if present)
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"

          # Update the VERSION constant in the version file
          sed -i "s/VERSION = \".*\"/VERSION = \"$VERSION\"/" \
            server/szuru_admin_version.py

          # Show what was updated
          echo "Updated version to: $VERSION"
          cat server/szuru_admin_version.py

          # Check if the file actually changed
          if git diff --quiet server/szuru_admin_version.py; then
            echo "Version is already set to $VERSION, no changes needed"
            echo "version-matched=true" >> $GITHUB_OUTPUT
          else
            echo "Version file changed, committing and updating tag"
            echo "version-matched=false" >> $GITHUB_OUTPUT

            # Commit the changes
            git add server/szuru_admin_version.py
            git commit -m "Update version to $VERSION"

            # Push to default branch
            git push origin ${{ github.event.repository.default_branch }}

            # Move the tag to point to the new commit
            # Preserve annotation if tag is annotated
            TAG_NAME="${{ github.ref_name }}"
            if git cat-file -t "$TAG_NAME" | grep -q "^tag$"; then
              # Tag is annotated, preserve the annotation
              TAG_MESSAGE=$(git tag -l --format='%(contents)' "$TAG_NAME")
              git tag -d "$TAG_NAME"
              git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
            else
              # Tag is lightweight, just move it
              git tag -f "$TAG_NAME"
            fi
            git push -f origin ${{ github.ref_name }}

            # Get release information to recreate it
            RELEASE_INFO=$(gh release view ${{ github.ref_name }} --json name,body,isDraft,isPrerelease)
            if [ -z "$RELEASE_INFO" ]; then
              echo "Error: Failed to retrieve release information for ${{ github.ref_name }}. Aborting to prevent malformed release."
              exit 1
            fi
            RELEASE_NAME=$(echo "$RELEASE_INFO" | jq -r '.name')
            RELEASE_BODY=$(echo "$RELEASE_INFO" | jq -r '.body')
            IS_DRAFT=$(echo "$RELEASE_INFO" | jq -r '.isDraft')
            IS_PRERELEASE=$(echo "$RELEASE_INFO" | jq -r '.isPrerelease')

            # Delete the existing release
            gh release delete ${{ github.ref_name }} --yes

            # Recreate the release with the updated tag
            # Write the release body to a temporary file to safely handle special characters
            NOTES_FILE=$(mktemp)
            echo "$RELEASE_BODY" > "$NOTES_FILE"

            # Build the gh release create command with safe argument passing
            CREATE_ARGS=(--title "$RELEASE_NAME" --notes-file "$NOTES_FILE")
            if [ "$IS_DRAFT" = "true" ]; then
              CREATE_ARGS+=("--draft")
            fi
            if [ "$IS_PRERELEASE" = "true" ]; then
              CREATE_ARGS+=("--prerelease")
            fi

            gh release create "${{ github.ref_name }}" "${CREATE_ARGS[@]}"

            rm -f "$NOTES_FILE"
            echo "Release recreated with updated tag. Workflow will terminate."
          fi

  tarball:
    name: Create and Upload Tarball
    runs-on: ubuntu-latest
    needs: check-version
    if: needs.check-version.outputs.version-matched == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.ref_name }}
      - name: Create Tarball
        run: ./make-dist.sh ${{ github.ref_name }} | tee /dev/stdout > TARBALL_NAME
      # Since this is all within the same job, could just load the tarball name
      # directly from TARBALL_NAME file, keeping it using GITHUB_ENV so I have
      # a future reference.
      #
      # NOTE: DO NOT QUOTE VALUES SENT TO $GITHUB_ENV! it will read the quotes
      # as part of the value.
      - name: Load Tarball Name
        run: echo "TARBALL_NAME=$(cat TARBALL_NAME)" >> $GITHUB_ENV
      - name: Verify Files
        run: ls -la
      - name: Upload To Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: gh release upload ${{ github.ref_name }} "$TARBALL_NAME"
