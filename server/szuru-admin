#!/usr/bin/env python3

"""
Collection of CLI commands for an administrator to use
"""

import logging
import os
import re
import time
import math
from getpass import getpass
from sys import stderr
from typing import Any, Iterable, Union, Tuple, Callable, List, Set
import random
import string
import datetime
import secrets

from szurubooru import config, db, errors, model
from szurubooru import search as szurusearch
from szurubooru.func import files, images
from szurubooru.func import posts as postfuncs
from szurubooru.func import users as userfuncs
from szurubooru.func import tag_categories as tagcatfuncs
from szurubooru.func import tags as tagfuncs
from szurubooru.func import snapshots

import szuru_admin_argparse

VERSION = "2.1"

_sys_user = None

def get_system_user():
    global _sys_user

    if _sys_user is not None:
        return _sys_user

    sys_user_name = 'szuru-admin-script'
    u = userfuncs.try_get_user_by_name(sys_user_name)
    if u is None:
        password = ''.join(secrets.choice(string.ascii_letters + string.digits) for i in range(25))
        u = userfuncs.create_user(sys_user_name, password, sys_user_name + '@system.user')
        u.rank = model.User.RANK_ADMINISTRATOR
        db.get_session().add(u)
        db.get_session().flush()

    _sys_user = u
    return u


def resync(ids: List[int], verbose: bool) -> None:
    """
    Refresh post data from the content currently in its file on disk.
    """
    vprint, vseparate = _vprinters(verbose)
    
    # load post, which might not exist, before trying to load files
    for post_id in ids:
        p = postfuncs.get_post_by_id(post_id)
        path = postfuncs.get_post_content_path(p)
        fcontent = files.get(path)
        if fcontent is None:
            raise errors.ValidationError("loaded image data for {:d} is blank".format(post_id))

        # chuck it in
        postfuncs.update_post_content(p, fcontent)
        db.get_session().flush()
        snapshots.modify(p, auth_user=get_system_user())
        
        print("Will refresh content data for post {:d}...".format(post_id))
    
    db.get_session().commit()
    print("Successfully updated all content")


def mass_rename_tags(old: str, new: str, preserve: bool, category: str, verbose: bool, apply: bool) -> None:
    """
    Rename all tags matching the old pattern to the new pattern. Uses regular
    expressions for matching and replacing. Not actually applied unless apply
    is set to True.

    If preserve is given, the tag will keep its old name as an alias.
    """
    vprint = print if verbose else lambda *args, **kwargs: None
    def vseparate():
        vprint("-" * 60)

    if not old or not new:
        raise errors.ValidationError("Both old and new patterns must be provided")

    old_pat = re.compile(old)

    vprint("Getting tags from DB...")

    full_tag_list = list()
    if category is not None and category != '':
        vprint(f"Querying for tags in category {category!r}")
        tagcat = tagcatfuncs.get_category_by_name(category, False)

        tag_list = (
            db.session.query(model.Tag)
            .filter(model.Tag.category == tagcat)
            .order_by(model.Tag.first_name)
            .all()
        )

        full_tag_list = (
            db.session.query(model.Tag)
            .order_by(model.Tag.first_name)
            .all()
        )
    else:
        vprint("Querying for all tags as no category was provided")
        tag_list = (
            db.session.query(model.Tag)
            .order_by(model.Tag.first_name)
            .all()
        )

        full_tag_list = list(tag_list)
        
    existing_tags_by_id = {t.tag_id: t for t in full_tag_list}

    replacements = list()
    has_no_ops = False

    vprint(f"Found {_p(tag_list, 'tag')}")
    vseparate()
    vprint(f"Filtering by tag first names matching {old_pat.pattern!r}")
    vprint(f"Replacing with '{new}'")

    for t in tag_list:
        m = old_pat.search(t.first_name)
        if m is not None:
            new_name = old_pat.sub(new, t.first_name)
            if new_name.lower() != t.first_name.lower():
                vprint(f"Matched {t.first_name!r} -> {new_name!r}")
                replacements.append((t, new_name))
            else:
                vprint(f"Skip {t.first_name!r}; substitution results in same name")
                has_no_ops = True
    
    vprint(f"Got {_p(replacements, 'rename')} to apply")
    vseparate()

    if len(replacements) < 1:
        if has_no_ops > 0:
            print("No matched tags would change", file=stderr)
            return
        else:
            print("No tags matched", file=stderr)
            return

    vprint("Getting all tag names from DB for conflict check...")
    name_list = (
        db.session.query(model.TagName)
        .order_by(model.TagName.name)
        .all()
    )
    vprint(f"Found {_p(name_list, 'tag name')}")
    vseparate()

    existing_names = {n.name.lower(): n for n in name_list}
    renamed_tags = {}
    renamed_names_by_old_name = {}
    simulated_existing = set(existing_names.keys())
    actions = list()

    rename_count = 0
    merge_count = 0
    vprint("Converting conflicting renames to merges...")
    for tag, new_fname in replacements:
        if new_fname.lower() in simulated_existing:
            # do this at the start of each path instead of after the if so we
            # don't have to worry about renames that go to the same name
            simulated_existing.remove(tag.first_name.lower())

            if new_fname.lower() in existing_names:
                # merging to a tag that existed before this script was run

                # TODO: I feel like there's a way to get this tag via the FK
                # relationship on the existing name we already have, but whatever
                # we already have tags in-mem so may as well just use that
                target_id = existing_names[new_fname.lower()].tag_id
                target = existing_tags_by_id[target_id]
            else:
                # merging to a tag that we will rename
                target = renamed_tags[new_fname.lower()]

            merge_count += 1
            actions.append(('merge', tag, new_fname, target))
        else:
            # do this at the start of each path instead of after the if so we
            # don't have to worry about renames that go to the same name
            simulated_existing.remove(tag.first_name.lower())
            simulated_existing.add(new_fname.lower())
            renamed_tags[new_fname.lower()] = tag
            renamed_names_by_old_name[tag.first_name.lower()] = new_fname.lower()

            rename_count += 1
            actions.append(('rename', tag, new_fname, tag))

    vprint(f"Result: {_p(rename_count, 'rename')}, {_p(merge_count, 'merge')}")
    vseparate()
    
    if apply:    
        vprint("All checks done; applying...")
    else:
        vprint("All checks done; listing changes without applying...")
    vseparate()

    for act in actions:
        action_type, tag, new_name, target = act

        if action_type == 'merge':
            target_name_clause = ''
            target_final_name = target.first_name.lower()
            if target_final_name in renamed_names_by_old_name:
                target_final_name = renamed_names_by_old_name[target_final_name]
            
            if new_name.lower() != target_final_name:
                target_name_clause = f" ({target.first_name!r})"
            print(f"MERGE:  {tag.first_name!r} => {new_name!r}{target_name_clause}")

            if apply:
                all_new_names = list()
                all_target_names = []
                all_t_names = []
                for n in target.names:
                    all_new_names.append(n.name)
                    all_target_names.append(n.name)
                for n in tag.names:
                    all_t_names.append(n.name)
                    # exclude the new tag name (and the original one unless preserve is specified)
                    if (preserve or n.name.lower() != tag.first_name.lower()) and n.name.lower() != new_name.lower():
                        all_new_names.append(n.name)

                vprint(f"Merging {all_t_names!r} into {all_target_names!r}")
                tagfuncs.merge_tags(tag, target)
                snapshots.merge(tag, target, auth_user=get_system_user())
                db.get_session().flush()

                vprint(f"Update to: {all_new_names!r}")
                tagfuncs.update_tag_names(target, all_new_names)
                db.get_session().flush()
                snapshots.modify(target, auth_user=get_system_user())

        elif action_type == 'rename':
            print(f"RENAME: {tag.first_name!r} -> {new_name!r}")

            if apply:
                all_new_names = list()
                all_new_names.append(new_name)

                for n in tag.names:
                    if preserve or n.name.lower() != tag.first_name.lower():
                        all_new_names.append(n.name)
                tagfuncs.update_tag_names(tag, all_new_names)
                db.get_session().flush()
                snapshots.modify(tag, auth_user=get_system_user())

        else:
            raise errors.ValidationError("Unknown action type: %s" % action_type)

    if preserve:
        print("All tags will preserve their old names as aliases")

    if not apply:
        print("No changes applied; if above looks correct, re-run with --apply")
    else:
        db.get_session().commit()
        print("All changes applied")
        print("WARNING: Active servers will not see changes until a client mutates something.")



def mass_tag(
        search: str,
        tags: List[str],
        removal: bool=False,
        implications: bool=False,
        category: str='',
        verbose: bool=False,
        apply: bool=False) -> None:
    """
    Tags posts that match pattern with the given tags (or removes them if
    removal is set to True). If implications is True, the tags in the tags list
    passed to this function will have tags they imply added to the list of tags
    to add/remove before the operation is applied.

    If no tags are given, this functions as a simple search to list posts that
    match the pattern.

    Not actually applied unless apply is set to True.

    If category is given and is not empty or None, newly-created tags will be
    in that category; otherwise they will be in the default.
    """
    # get verbose printers
    vprint, vseparate = _vprinters(verbose)

    # check if any tags need to be created and/or if implications need to be applied to the given tags
    all_added = set()
    vprint("Checking new tags for tag existence" + (" and implications" if implications else "") + "...")
    tags_to_create = set()
    tags_with_implied = set(tags)
    for tname in tags:
        t = tagfuncs.try_get_tag_by_name(tname)
        if not t:
            # no implications if the tag doesn't exist; not an error
            vprint(f"{tname!r} does not exist" + ("; skipping implications check" if implications else ""))
            tags_to_create.add(tname)
            continue

        vprint(f'Tag {tname!r} exists' + ("; running implications check..." if implications else ""))

        if implications:
            if len(t.implications) < 1:
                vprint(f"{tname!r} has no implications")
                continue

            all_impls = _get_recursive_implications(t)
            as_str = ', '.join(f'{impl.first_name!r}' for impl in all_impls)

            vprint(f"{tname!r} -> {as_str}")
            for implied_tag in all_impls:
                if implied_tag.first_name not in tags_with_implied:
                    all_added.add(implied_tag.first_name)
                tags_with_implied.add(implied_tag.first_name)

    if implications:
        tags = sorted(list(tags_with_implied))
        op = 'added' if not removal else 'removed'

        if len(all_added) > 0:
            vprint(f"{_p(all_added, 'additional tag')} will be {op} by implication")
            print("Implied tag(s): {:s}".format(', '.join(f'`{t}`' for t in sorted(list(all_added)))))
        else:
            vprint("Found no additional tags by implication")
            print("Implied tag(s): (none)")
    else:
        tags = sorted(list(set(tags)))
    
    vseparate()

    # do search of posts to get candidates
    conf = szurusearch.configs.PostSearchConfig()
    searcher = szurusearch.Executor(conf)
    vprint("Search with {!r}".format(search))

    posts: List[model.Post] = []
    # get all posts until total agrees with actual
    while True:
        total_count = postfuncs.get_post_count()
        count, posts = searcher.execute(search, 0, total_count)

        if count == len(posts):
            break

        vprint("Got different count of search than expected; re-trying to avoid concurrent modification...")
    vprint("Total: {:d}".format(count))

    def id_to_link(id):
        return f"{config.config['domain']}/post/{id}"
    
    for post in posts:
        p: model.Post = post
        vprint(f"Matched post {p.post_id} - {id_to_link(p.post_id)}")
    
    vseparate()
    
    post_msgs = []
    changed_posts = {} # id -> (post, new_tags, mods)
    for post in posts:
        p: model.Post = post

        changes = []
        new_tags = []

        existing_set = set()

        for t in p.tags:
            if removal:
                if all(n.name not in tags for n in t.names):
                    new_tags.append(t.first_name)
                else:
                    changes.append(t.first_name)
            else:
                new_tags.append(t.first_name)
                existing_set.update(n.name for n in t.names)
        
        if not removal:
            for tname in tags:
                if tname not in existing_set:
                    new_tags.append(tname)
                    changes.append(tname)
                    existing_set.add(tname)

        changes.sort()
        if len(changes) > 0:
            changed_posts[p.post_id] = (p, new_tags, changes)
            op = 'Add' if not removal else 'Remove'
            post_msgs.append(f"{id_to_link(p.post_id)} - {op} {', '.join(f'`{t}`' for t in changes)}")
        else:
            post_msgs.append(f"{id_to_link(p.post_id)} - No changes")
    
    if len(changed_posts) < 1:
        print("No posts to modify")
        return
    
    for msg in post_msgs:
        print(msg)
    
    tagcat = None
    if len(tags_to_create) > 0 and not removal:
        vseparate()
        if category is not None and category != '':
            vprint(f"Querying for category {category!r}...")
            tagcat = tagcatfuncs.get_category_by_name(category, False)
        else:
            vprint("Querying for default category for creation of tags...")
            tagcat = tagcatfuncs.get_default_category()
        vseparate()
        print(f"New tags to create in category {tagcat.name!r}: " + ', '.join(f'`{t}`' for t in tags_to_create))

    op = 'addition' if not removal else 'removal'
    print(f"Tag {op} will be applied to {len(changed_posts)} out of {_p(posts, 'post')} matched")

    if not apply:
        print("No changes applied; if above looks correct, re-run with --apply")
    else:
        vseparate()

        if len(tags_to_create) > 0 and not removal:
            created_tags = []
            for t in tags_to_create:
                vprint(f"Create tag {t!r}...")
                new_tag = tagfuncs.create_tag([t], tagcat.name, [], [])
                created_tags.append(new_tag)
                db.get_session().add(new_tag)
            db.get_session().flush()
        
            for t in created_tags:
                snapshots.create(t, auth_user=get_system_user())

            vseparate()

        updated_posts = []
        for pid in changed_posts:
            vprint(f"Update post {pid}...")
            p, new_tags, _ = changed_posts[pid]
            postfuncs.update_post_tags(p, new_tags)
            p.last_edit_time = datetime.datetime.utcnow()
            updated_posts.append(p)
        db.get_session().flush()

        for p in updated_posts:
            snapshots.modify(p, auth_user=get_system_user())

        vseparate()

        db.get_session().commit()
        print("Post changes applied")
        print("WARNING: Active servers might not see changes until a client mutates something.")


def mass_move_tags(search: str, new_cat: str, from_cat: str, verbose: bool, apply: bool) -> None:
    """
    Update the category of all tags matching the search pattern within the
    category given by from_cat, or within all categories if from_cat is empty or
    not given. Not actually applied unless apply is set to True.
    """
    vprint, vseparate = _vprinters(verbose)

    if not search or not new_cat.strip():
        raise errors.ValidationError("Both search and new category must be provided")

    search_pat = re.compile(search)

    new_cat_exists = False
    vprint(f"Checking if new category {new_cat!r} exists...")
    new_cat_name = new_cat.strip()
    new_cat = tagcatfuncs.try_get_category_by_name(new_cat_name, False)
    if new_cat is None:
        vprint(f"New category does not yet exist and will be created")
    else:
        new_cat_exists = True
        vprint(f"Category already exists")

    vprint("Getting tags from DB...")
    if from_cat is not None and from_cat != '':
        vprint(f"Querying for tags in category {from_cat!r}")
        tagcat = tagcatfuncs.get_category_by_name(from_cat, False)

        tag_list = (
            db.session.query(model.Tag)
            .filter(model.Tag.category == tagcat)
            .order_by(model.Tag.first_name)
            .all()
        )
    else:
        vprint("Querying for all tags as no category was provided")
        tag_list = (
            db.session.query(model.Tag)
            .order_by(model.Tag.first_name)
            .all()
        )

    updates = list()
    has_no_ops = False

    vprint(f"Found {_p(tag_list, 'tag')}")
    vseparate()
    vprint(f"Filtering by tag first names matching {search_pat.pattern!r}")    

    for t in tag_list:
        m = search_pat.search(t.first_name)
        if m is not None:
            if t.category.name.lower() != new_cat_name.lower():
                vprint(f"Matched {t.first_name!r}")
                updates.append(t)
            else:
                vprint(f"Skip {t.first_name!r}; already in category {new_cat!r}")
                has_no_ops = True

    vprint(f"Got {_p(updates, 'tag')} to move")
    vseparate()

    if len(updates) < 1:
        if has_no_ops > 0:
            print("All matched tags are already in category", file=stderr)
            return
        else:
            print("No tags matched", file=stderr)
            return
    
    if apply:    
        vprint("Moving tags to new category...")
    else:
        vprint("Listing tags to move...")
    vseparate()

    if not new_cat_exists:
        print(f"CREATE new category {new_cat_name!r}")
        if apply:
            new_cat = tagcatfuncs.create_category(new_cat_name, '#0073ff', 1)
            db.session.add(new_cat)
            db.session.flush()
            snapshots.create(new_cat, auth_user=get_system_user())

    updated_tags = []
    new_clause = '' if new_cat_exists else 'new '
    for t in updates:
        t.category = new_cat
        print(f"MOVE {t.first_name!r} to {new_clause}category {new_cat_name!r}")
        if apply:
            db.session.add(t)
            updated_tags.append(t)
    if apply:
        db.session.flush()
        for t in updated_tags:
            snapshots.modify(t, auth_user=get_system_user())
 
    if not apply:
        print("No changes applied; if above looks correct, re-run with --apply")
    else:
        db.get_session().commit()
        print("All changes applied")
        print("WARNING: Active servers will not see changes until a client mutates something.")


def reset_password(username: str) -> None:
    user = userfuncs.get_user_by_name_or_email(username)

    new_password = getpass("Enter new password for '%s': " % user.name)
    check_password = getpass("Re-enter password: ")

    if check_password != new_password:
        raise errors.ValidationError("Passwords do not match")

    userfuncs.update_user_password(user, new_password)
    db.get_session().commit()
    print("Sucessfully changed password for '%s'" % user.name)


def check_audio() -> None:
    post_list = (
        db.session.query(model.Post)
        .filter(model.Post.type == model.Post.TYPE_VIDEO)
        .order_by(model.Post.post_id)
        .all()
    )

    for post in post_list:
        print("Checking post %d ..." % post.post_id, end="\r", file=stderr)
        content = files.get(postfuncs.get_post_content_path(post))

        has_existing_flag = model.Post.FLAG_SOUND in post.flags
        try:
            has_sound_data = images.Image(content).check_for_sound()
        except errors.ProcessingError:
            print(
                "Post %d caused an error when checking for sound"
                % post.post_id
            )

        if has_sound_data and not has_existing_flag:
            print("Post %d has sound data but is not flagged" % post.post_id)
        if not has_sound_data and has_existing_flag:
            print("Post %d has no sound data but is flagged" % post.post_id)


def reset_filenames() -> None:
    regex = re.compile(r"(\d+)_[0-9a-f]{16}\.(\S+)")

    def convert_to_new_filename(old_name: str) -> str:
        matches = regex.match(old_name)
        if not matches:
            return None
        post_id = int(matches.group(1))
        post_ext = matches.group(2)
        return "%d_%s.%s" % (
            post_id,
            postfuncs.get_post_security_hash(post_id),
            post_ext,
        )

    def rename_in_dir(dir: str) -> None:
        for old_path in os.listdir(config.config["data_dir"] + dir):
            new_path = convert_to_new_filename(old_path)
            if not new_path:
                continue
            if old_path != new_path:
                print("%s -> %s" % (dir + old_path, dir + new_path))
                os.rename(
                    config.config["data_dir"] + dir + old_path,
                    config.config["data_dir"] + dir + new_path,
                )

    rename_in_dir("posts/")
    rename_in_dir("generated-thumbnails/")
    rename_in_dir("posts/custom-thumbnails/")


def show_version() -> None:
    """
    Print the current version of szuru-admin.
    """
    print(VERSION)


def main() -> None:
    command = szuru_admin_argparse.parse_args()

    try:
        if command.subcommand == "change-password":
            reset_password(command.username)
        elif command.subcommand == "check-all-audio":
            check_audio()
        elif command.subcommand == "reset-filenames":
            reset_filenames()
        elif command.subcommand == "version":
            show_version()
        elif command.subcommand == "rename-tags":
            mass_rename_tags(
                command.pattern,
                command.replacement,
                command.preserve,
                command.category,
                command.verbose,
                command.apply,
            )
        elif command.subcommand == "move-tags":
            mass_move_tags(
                command.search,
                command.new_category,
                command.category,
                command.verbose,
                command.apply,
            )
        elif command.subcommand == 'resync':
            resync(command.id, command.verbose)
        elif command.subcommand == 'tag':
            mass_tag(
                command.search,
                command.tags,
                command.delete,
                command.imply,
                command.category,
                command.verbose,
                command.apply,
            )
        else:
            raise errors.ValidationError("Unknown subcommand: %s" % command.subcommand)
    except errors.BaseError as e:
        print(e, file=stderr)


def _p(count: Union[int, Iterable[Any]], root: str, plural_suf: str='s', singular_suf: str='') -> str:
    """
    Returns the singular or plural form of a word based on the count.
    """
    if isinstance(count, Iterable):
        count = len(count)

    if count == 1:
        return f"{count} {root}{singular_suf}"
    else:
        return f"{count} {root}{plural_suf}"


def _vprinters(verbose: bool) -> Tuple[Callable, Callable]:
    vprint = print if verbose else lambda *args, **kwargs: None
    vseparate = lambda: vprint("-"*60)
    return vprint, vseparate


def _get_recursive_implications(tag: model.Tag, results: Set[model.Tag]=None) -> Set[model.Tag]:
    if results is None:
        results = set()

    for impl in tag.implications:
        if any(impl.first_name == t for t in results):
            continue

        results.add(impl)
        new_results = _get_recursive_implications(impl, set(results))
        # remove the tag itself from the results; this avoids circular implications
        new_results.discard(tag)
        results.update(new_results)
    return results


def _bytes_to_iec_units(b: int, pluralize=True, mag_0_name='byte', precision=1) -> Tuple[float, str]:
    """
    Convert a number of bytes to the highest IEC binary prefixed unit that there
    is at least one of. Return a tuple containing the count of data in that unit
    represented by b, and a string containing both b and the unit name itself
    using IEC abbreviations (MiB, GiB, etc). For example, 1024 would return
    (1.0, '1.0 KiB'), 1536 would return (1.5, '1.5 KiBs'), and 20971520 would
    return (20.0, '20.0 MiB').
    
    Units up to the exabyte order of magnitude are supported. Prefixes higher
    than EiB will simply be represented as their equivalent EiB amount.
    
    If b is less than 1024, the unabbreviated name 'byte' is used as the unit
    name, so for instance if b were 512, the full returned string would be
    '512 bytes'. This name can be modified by setting mag_0. Additionally, the
    numerical value in this case is always formatted as an int, not a float.

    Returned unit names will be pluralized unless b converts to exactly one of
    that unit; set pluralize to false to disable this behavior and always return
    singular names.
    
    Precision by default will be one floating point decimal, but can be changed
    by setting the parameter precision to a different value.
    """
    unit_names = [mag_0_name, 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB']
    mag = int(math.log(b, 1024))
    if mag >= len(unit_names):
        mag = len(unit_names) - 1

    # do the math
    amount = b / 1024**mag
    unit = unit_names[mag] + 's' if pluralize and amount != 1.0 else ''
    
    val_str = ''
    if mag == 0:
        val_str += '{:d}'.format(int(amount))
    else:
        val_str += '{:.{prec}f}'.format(amount, prec=precision)

    return amount, '{:s} {:s}'.format(val_str, unit)


if __name__ == "__main__":
    main()

